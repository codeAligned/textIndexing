\section{Sampling}

Instead of storing the complete suffix array we can only store a subset of the values to save space.

\begin{Definition}
  Fix a sampling parameter $s$ and add a bitvector $B$ of length $n$ with $B[i] = 1$ if and only if $SA[i] \equiv 0 \mod s$. Store exactly those elements of $SA$ in another array $SA'$ of size $\lceil \frac{n}{s} \rceil$, the \defi{sampled suffix array}{Sampled Suffix Array}. For all $i$ with $B[i] = 1$, we get
  \begin{align}
    SA'[\mathrm{rank}_1(i, B)] := SA[i]
    \text{.}
  \end{align}
  This is known as \defi{SA-order-sampling}{SA-Order-Sampling}.
\end{Definition}

\begin{Definition}
  Fix a sampling parameter $s$. Store exactly those elements $SA[i]$ with $i \equiv 0 \mod s$ in another array $SA'$ of size $\lceil \frac{n}{s} \rceil$. We get
  \begin{align}
    SA'[i/s] := SA[i]
    \text{.}
  \end{align}
  This is known as \defi{Text-order-sampling}{Text-Order-Sampling}.
\end{Definition}

No matter which of the above sampling strategies above is used, the code in Algorithm~\ref{alg:sampledSuffixArrayAccess} allows to access arbitrary elements of the suffix array.

\begin{pseudocode}
  {$\mathrm{access}$}
  {sampledSuffixArrayAccess}
  {Index $i$ to access.}
  {Value of $SA[i]$.}
  \STATE $k \gets 0$
  \WHILE{$B[i] == 0$}
    \STATE $k \gets k + 1$
    \STATE $i \gets LF[i]$
  \ENDWHILE
  \RETURN $SA'[rank_1(i, B)] + k$
\end{pseudocode}

\begin{Theorem}
  If SA-order-sampling is used, the $\mathrm{access}$-method in Algorithm~\ref{alg:sampledSuffixArrayAccess} takes at most $\mathcal{O}(s\cdot t_{LF})$ time, where $t_{LF}$ is the time for an access in the $LF$ array.
\end{Theorem}

\begin{Proof}
  Assume we want to access index $i$ of the suffix array $SA$ and let $j = SA[i]$. Each $i \leftarrow LF[i]$ call executed in Algorithm~\ref{alg:sampledSuffixArrayAccess} $j$ becomes $j-1$, so after at most $s - 1$ iterations $j - k = SA[i]$ is divisible by $s$ and therefore sampled. We can return $j - k + k = j$.
\end{Proof}

\begin{Theorem}
  SA-order-sampling as described needs at most $\frac{n}{s}\log n + 2n$ bits space. This can be improved to $\frac{n}{s}\log\frac{n}{s} + 2n$ bits, with the $\mathrm{access}$-operation still needing time in $\mathcal{O}(s\cdot t_{LF})$.
\end{Theorem}

\begin{Proof}
  The sampled suffix array has $\frac{n}{s}$ elements, each an integer from $[0,n]$. The additional $2n$ bits are $n$-bit bitvector $B$ and the overhead to allow $\mathrm{rank}$-operations in constant time.

  The necessary observation to reduce the space needed is that each sampled element $SA[i]$ is a multiple of the sampling parameter $s$. So instead of \begin{align}
    SA'[\mathrm{rank}_1(i, B)] := SA[i]
  \end{align}
  we can write
  \begin{align}
    SA'[\mathrm{rank}_1(i, B)] := \frac{SA[i]}{s}
    \text{.}
  \end{align}
  The access operation stays the same, instead of the return call in the last line: We need to multiply the value read from $SA'$ by $s$.
\end{Proof}

% TODO (pjungeblut): Describe ISA sampling. (Project 1, Exercise 3)
% TODO (pjungeblut): Compare SA-order-sampling and text-order-sampling.
%                    (Project 2, Exercise 1)
